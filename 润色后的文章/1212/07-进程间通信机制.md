# 进程间通信机制

## 进程间通信概述

进程间通信（Inter-Process Communication, IPC）是指两个或多个独立进程之间交换数据的方法。在Unix/Linux系统中，由于进程之间相互隔离，不能直接访问对方的内存空间，因此需要专门的通信机制。

### 为什么需要进程间通信

在MCP和Agent系统中，进程间通信主要出现在以下场景：
- Agent进程调用MCP Server进程
- CLI包装器启动子进程执行工具
- 不同服务进程间的数据交换

## subprocess与进程通信

### subprocess基本概念

subprocess是Python的标准库，用于创建和管理子进程。它不仅能启动外部进程，还负责父子进程之间的通信。

```python
import subprocess

# 基本的进程创建
result = subprocess.run(
    ["ls", "-la"],
    capture_output=True,
    text=True
)
print(result.stdout)
```

### subprocess使用的通信方式

subprocess主要通过**标准输入输出（Standard I/O）**进行进程间通信：
- **stdin（标准输入）**：父进程向子进程发送数据
- **stdout（标准输出）**：子进程向父进程返回正常结果
- **stderr（标准错误）**：子进程向父进程返回错误信息

```python
# 通过stdin发送数据，从stdout读取结果
process = subprocess.Popen(
    ["grep", "error"],
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    text=True
)

# 发送数据到子进程
output, _ = process.communicate(input="this is an error line\n")
print(output)  # 输出: this is an error line
```

## 管道（Pipe）通信

### 管道的本质

管道是Unix系统中最简单的IPC机制，其本质是内核中的一块缓冲区。数据在一个方向上流动，一端写入，另一端读取。

```mermaid
flowchart LR
    A[父进程] -->|写入| B[管道]
    B -->|读取| C[子进程]
```

### 匿名管道（Anonymous Pipe）

用于有亲缘关系的进程（如父子进程）：

```python
# Python通过pipe参数创建管道
import subprocess

# 创建两个管道：一个用于父到子，一个用于子到父
parent_to_child, child_to_parent = subprocess.Popen(
    ["cat", "-n"],
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE
)

# 父进程通过stdin向子进程发送数据
child_to_parent.communicate(input="Hello\nWorld\n")
```

### 命名管道（Named Pipe）

用于无亲缘关系的进程：

```bash
# 创建命名管道
mkfifo /tmp/mypipe

# 进程A写入数据
echo "Hello" > /tmp/mypipe

# 进程B读取数据
cat < /tmp/mypipe
```

## 在MCP系统中的应用

### CLI包装器的进程通信

当使用CLI包装器方式调用MCP工具时：

```python
def execute_mcp_tool_via_cli(tool_name: str, params: dict) -> str:
    """通过CLI包装器调用MCP工具"""
    # 构建命令
    command = f"python mcp_tool.py {tool_name} '{json.dumps(params)}'"

    # 创建子进程执行
    result = subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
        timeout=30  # 设置超时
    )

    if result.returncode != 0:
        raise Exception(f"Tool execution failed: {result.stderr}")

    return result.stdout
```

### 调用链分析

完整的调用链路：

```
1. Agent进程
   ↓ (subprocess.run)
2. Python解释器进程（执行mcp_tool.py）
   ↓ (函数调用)
3. MCP Client
   ↓ (网络/本地通信)
4. MCP Server进程
```

### 性能开销分析

每次通过subprocess调用都涉及：
1. **进程创建开销**：fork/exec系统调用
2. **内存复制开销**：进程初始化
3. **上下文切换开销**：CPU调度
4. **序列化开销**：数据在进程间传输

```python
# 测试进程创建开销
import time
import subprocess

def benchmark_subprocess():
    start = time.time()
    for i in range(100):
        subprocess.run(["echo", "test"], capture_output=True)
    end = time.time()
    print(f"100次subprocess调用耗时: {end-start:.2f}秒")

# 结果通常在几秒级别，远高于函数调用
```

## 高级IPC机制

### 套接字（Socket）

适用于网络通信和本地通信：

```python
# 服务器端
import socket

server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
server.bind("/tmp/mcp_socket")
server.listen(5)

# 客户端
client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
client.connect("/tmp/mcp_socket")
client.send(b'{"tool": "query", "params": {}}')
response = client.recv(1024)
```

### 共享内存（Shared Memory）

适用于大量数据交换：

```python
from multiprocessing import shared_memory
import numpy as np

# 创建共享内存
shm = shared_memory.SharedMemory(name="mcp_data")

# 写入数据
array = np.ndarray((100,), dtype=np.float64, buffer=shm.buf)
array[:] = np.random.rand(100)

# 另一个进程读取
existing_shm = shared_memory.SharedMemory(name="mcp_data")
array2 = np.ndarray((100,), dtype=np.float64, buffer=existing_shm.buf)
```

### 消息队列（Message Queue）

适用于异步通信：

```python
import multiprocessing

# 创建消息队列
queue = multiprocessing.Queue()

def worker():
    while True:
        message = queue.get()
        if message == "STOP":
            break
        process_message(message)

# 主进程发送消息
queue.put({"tool": "query", "data": "test"})
queue.put("STOP")
```

## 优化策略

### 1. 连接池

```python
class MCPProcessPool:
    def __init__(self, pool_size=5):
        self.pool = []
        for _ in range(pool_size):
            # 预创建子进程
            proc = subprocess.Popen(
                ["python", "mcp_worker.py"],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE
            )
            self.pool.append(proc)

    def execute(self, command):
        # 复用已有进程
        proc = self.pool.pop()
        proc.stdin.write(command + "\n")
        proc.stdin.flush()
        result = proc.stdout.readline()
        self.pool.append(proc)
        return result
```

### 2. 批量操作

```python
def batch_execute(commands):
    """批量执行命令，减少进程创建开销"""
    with subprocess.Popen(
        ["python", "batch_processor.py"],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        text=True
    ) as proc:
        # 一次性发送所有命令
        for cmd in commands:
            proc.stdin.write(cmd + "\n")
        proc.stdin.close()

        # 批量读取结果
        results = proc.stdout.readlines()
    return results
```

### 3. 异步执行

```python
import asyncio
from asyncio.subprocess import create_subprocess_exec

async def async_mcp_call(tool_name: str, params: dict):
    """异步执行MCP调用"""
    proc = await create_subprocess_exec(
        "python", "mcp_tool.py", tool_name, json.dumps(params),
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )

    stdout, stderr = await proc.communicate()

    if proc.returncode != 0:
        raise Exception(f"Error: {stderr.decode()}")

    return json.loads(stdout.decode())

# 并发执行多个调用
async def run_multiple_calls():
    tasks = [
        async_mcp_call("query1", params1),
        async_mcp_call("query2", params2),
        async_mcp_call("query3", params3)
    ]
    results = await asyncio.gather(*tasks)
    return results
```

## 错误处理和调试

### 常见错误类型

1. **进程启动失败**
   ```python
   try:
       subprocess.run(["nonexistent_command"])
   except FileNotFoundError:
       print("Command not found")
   except PermissionError:
       print("Permission denied")
   ```

2. **死锁**
   ```python
   # 危险：可能导致死锁
   proc = subprocess.Popen([...], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
   # 如果缓冲区满，进程会等待读取，导致死锁
   ```

3. **超时处理**
   ```python
   try:
       result = subprocess.run(
           command,
           timeout=30,
           capture_output=True
       )
   except subprocess.TimeoutExpired:
       print("Command timed out")
       proc.kill()  # 终止进程
   ```

### 调试技巧

1. **详细日志**
   ```python
   logging.info(f"Executing: {command}")
   result = subprocess.run(command, capture_output=True, text=True)
   logging.info(f"Exit code: {result.returncode}")
   logging.info(f"Stdout: {result.stdout}")
   if result.stderr:
       logging.error(f"Stderr: {result.stderr}")
   ```

2. **环境变量检查**
   ```python
   env = os.environ.copy()
   env["PYTHONPATH"] = "/path/to/modules"

   result = subprocess.run(
       command,
       env=env,  # 传递修改后的环境变量
       capture_output=True
   )
   ```

## 性能对比

### 不同IPC方式的性能特征

| 机制 | 数据传输速率 | 延迟 | 适用场景 |
|------|-------------|------|----------|
| 管道 | 中等 | 低 | 简单数据，父子进程 |
| Socket | 中等 | 中等 | 网络通信，跨机器 |
| 共享内存 | 高 | 低 | 大量数据，同机器 |
| 消息队列 | 低 | 高 | 异步，解耦通信 |

### subprocess vs 函数调用

```python
# subprocess调用（约1-10ms）
result = subprocess.run(["python", "-c", "print(2+2)"], capture_output=True)

# 函数调用（约1-10μs，快1000倍）
def add():
    return 2+2
result = add()
```

> [!warning] 性能权衡
subprocess调用比直接函数调用慢1000倍以上。在高频场景下，考虑使用[[MCP集成实现方案]]中提到的直接集成方式。

## 相关概念

- [[MCP集成实现方案]]：了解不同集成方案的性能差异
- [[mini-swe-agent深度解析]]：查看subprocess在Agent中的实际应用
- [[CLI程序开发实践]]：学习如何创建高效的CLI包装器

## 总结

进程间通信是构建分布式系统的基础。在MCP和Agent系统中，subprocess是最简单但性能较差的方式，适用于低频调用场景。对于高性能要求，需要考虑更高级的IPC机制或进程内集成。理解不同通信方式的特点和权衡，有助于选择最适合的解决方案。