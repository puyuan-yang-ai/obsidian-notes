MCP是什么类型的协议？ | 通信协议
MCP server的本质是什么？ | 后台应用程序
MCP tool的本质是什么？ | MCP server对外暴露的功能接口，类似于函数
MCP tool包含哪些内容？ | 名称、说明、参数、返回值的schema以及权限
MCP采用什么架构？ | 客户端/服务端架构（C/S架构）
MCP的C/S架构中，客户端和服务端各自的作用是什么？ | 客户端位于AI端，负责发起调用请求；服务端暴露多个工具，好处是AI只需知道使用哪个工具，无需了解实现细节
MCP架构的哪部分位于AI模型端？ | 客户端（Client）
在LLM领域中，工具指的是什么？ | 外部功能
MCP中是由LLM直接触发工具调用吗？ | 不是，由MCP Client触发MCP Server上暴露的工具
请描述MCP的完整工作流程 | LLM生成工具调用指令 → MCP Client解析并转发调用 → MCP Server执行工具 → 返回结果 → MCP Client将结果传回LLM → LLM继续生成响应
在MCP流程中，LLM的作用是什么？ | 决定并输出调用意图（选择哪个工具及参数）
为什么MCP Server不能自己决定何时运行工具？ | 它只是工具提供者，不负责决策
MCP中client和server如何协作？ | Client向server发起tools/call请求
LLM无法直接调用外部功能和API的根本原因是什么？ | LLM只能生成文本
MCP Client连接MCP Server后，通过list_tools接口获取什么信息？ | 所有可用工具的定义（名称、schema、元数据）
MCP Client获取工具定义后，这些信息如何处理？ | 发送给LLM用于构造prompt/context，告诉LLM可以调用哪些工具
当用户发出请求时，LLM根据上下文和工具列表返回什么？ | 结构化调用指令（JSON格式，指定工具名和参数），用于决定调用哪个工具
MCP Client接收到LLM的调用指令后会做什么？ | 向对应的MCP Server发起tools/call请求，真正执行工具
MCP Server执行工具并返回结果后，结果如何处理？ | Server将结构化结果返回给Client，Client再将结果传给LLM作为新上下文，LLM基于此继续推理生成最终响应
MCP中"注册"的含义是什么？ | MCP Server将其tools/resources/prompts暴露出来，附带元数据和schema
LLM如何知道可以使用哪些MCP工具？ | MCP Client连接server后获取暴露的工具列表，并将工具定义注入LLM上下文
用户发送请求前，LLM就已经知道可用工具，这背后是什么流程？ | MCP Client启动并连接MCP Server → 通过协议获取所有可用工具 → Client将工具定义注入LLM上下文
LLM本身能执行外部代码或API吗？为什么？ | 不能，因为LLM只能生成文本
MCP Client连接MCP Server后依次做什么？ | 1. 获取Server暴露的工具列表 2. 将工具定义注入LLM上下文
Client将工具定义注入LLM上下文的作用是什么？ | 让LLM知道当前环境中有哪些工具可以调用
Client与LLM、Client与MCP Server之间的关系分别是什么？ | Client接收LLM的JSON调用指令，Client向MCP Server发起tools/call请求
MCP中"LLM负责决策"的含义是什么？ | 根据上下文判断是否需要调用工具，输出结构化调用意图（JSON格式）
MCP架构中，工具的触发者、决策者和执行位置分别是什么？ | 触发者：Client，决策者：LLM，执行位置：Server
Agent的两个独立部分是什么？ | AI推理模块（LLM/Model Caller）和MCP Client（工具调用与执行模块）
Agent中的AI推理模块本质是什么？是否执行代码？ | 本质是调用外部大模型，不执行代码，不访问系统资源，只产生决策和意图
Agent中的AI推理模块和MCP Client分别相当于什么身体部位？ | LLM是大脑，MCP Client是手脚
在MCP架构中，LLM和MCP Client各不做什么？ | LLM不执行代码，MCP Client不做推理
LLM和MCP Client如何分工？ | LLM决定调用哪个工具，MCP Client负责执行工具调用
mini-swe-agent的工作流程是什么？ | 用户给agent任务 → agent将任务发给LLM → LLM返回bash命令 → agent执行命令 → 返回结果给LLM → LLM继续思考并返回下一个命令...
mini-swe-agent只执行bash命令意味着什么？ | 它把所有任务都交给命令行处理
如何让mini-swe-agent调用MCP工具？ | 将MCP工具包装成bash命令
mini-swe-agent如何执行bash命令？ | 使用subprocess.run
为什么MCP服务器不一定需要通过MCP协议调用？ | MCP服务器本质上是Python函数，可以直接import使用
在mini-swe-agent项目中，为什么使用CLI包装器？ | CLI包装器将MCP工具变成命令行程序，作为桥梁让agent通过bash调用MCP工具
mini-swe-agent中Environment的职责是什么？ | 接收命令字符串，执行它，返回输出结果
请举例说明LLM和Environment的关系 | LLM返回"ls -la"，LocalEnvironment通过subprocess.run执行，然后将结果{output:...}返回给LLM
LocalEnvironment类的核心函数及其代码是什么？ | 核心函数是execute，核心代码是result = subprocess.run(command,...)
让mini-swe-agent兼容MCP的两种方式是什么？ | 方式①：Bash封装，方式②：修改Environment
两种MCP兼容方式在运行时开销上有什么区别？ | Bash方式：每次启动新Python进程，Environment方式：直接函数调用，无额外进程
为什么Bash封装方式在错误处理和调试方面更困难？ | 因为涉及两个独立程序和进程间通信
两种方式下，LLM需要生成的命令有什么区别？ | Bash封装：python amd-tool.py query '{"topic":"HIP"}'，Environment：@amd:query {"topic":"HIP"}
为什么Bash封装方式下LLM出错概率更高？ | LLM需要记住更多细节，而Environment方式只需记住简单格式
两种方式的调用链有什么区别？ | Bash：Agent→LocalEnvironment→subprocess.run→新Python进程，Environment：Agent→MCPEnabledEnvironment→直接函数调用→返回结果
Bash封装方式的调用链是怎样的？ | Agent→LocalEnvironment.execute()→subprocess.run→产生新Python进程→捕获stdout作为结果
修改Environment方式的调用链是怎样的？ | Agent→MCPEnabledEnvironment.execute()→检测@amd:前缀→直接函数调用→返回结果
MCP服务器返回哪两种信息？什么时候返回？ | 1. client连接时返回可用工具列表 2. client调用特定工具时返回执行结果
MCP服务器是独立运行的程序吗？ | 是的，是独立进程
扩展mini-swe-agent兼容MCP的关键入口点是哪个方法？ | Environment.execute()
Environment.execute()方法拦截的作用是什么？ | 方便mini-swe-agent接入任何外部工具
两种MCP兼容方式是否使用了MCP协议？为什么？ | 没有，而是将amd-ai-devtool当作Python库使用
amd-ai-devtool这个MCP server必须通过MCP协议调用吗？ | 不是必须的，虽然是MCP服务器，但底层是Python代码，可以直接import使用
LangChain中的@tool注解有什么作用？ | 将Python函数包装成LLM可调用工具的装饰器
@tool装饰器背后做了什么？ | 自动生成工具的schema，支持JSON参数调用格式
LangChain的@tool和MCP Server的tool面向的对象有什么区别？ | 前者面向LangChain Agent，后者面向MCP协议客户端/Server
可以用LangChain的@tool声明MCP工具吗？为什么？ | 不可以，因为面向的对象不同，@tool针对LangChain Agent
FastMCP框架使用装饰器定义工具的好处是什么？ | 大幅减少样板代码
开发MCP时应该使用FastMCP还是官方SDK？为什么？ | FastMCP，因为它提供了更Pythonic、高层、简洁的接口
FastMCP仅仅方便了MCP server开发吗？ | 不是，同时对MCP Client开发也有帮助
rocm/pytorch:rocm6.4.3_ubuntu22.04_py3.10_pytorch_release_2.6.0的结构是什么？ | <repository>/<image_name>:<tag>
Docker镜像名称的三个部分分别是什么？ | 1. rocm/pytorch：镜像仓库+名称 2. rocm6.4.3_ubuntu22.04_py3.10_pytorch_release_2.6.0：镜像标签
docker images如何显示带标签的镜像？ | REPOSITORY列显示冒号前部分，TAG列显示冒号后部分
mini-swe-agent的两个主要部分及其作用是什么？ | Model（LLM调用部分）、Environment（执行部分）
mini-swe-agent直接使用什么执行bash命令？ | subprocess.run
mini-swe-agent无状态shell会话是什么意思？ | 每个命令都是独立执行的
mini-swe-agent从Prompt构建开始的执行流程是什么？ | Prompt构建→LLM调用→解析输出→执行→反馈循环
mini-swe-agent入门涉及的三个文件及作用是什么？ | agents/default.py（Agent循环核心）、environments/local.py（执行环境）、models/litellm_model.py（LLM调用封装）
agents/default.py的作用是什么？ | 实现Agent循环的核心逻辑
environments/local.py的作用是什么？ | 提供极简的执行环境
models/litellm_model.py的作用是什么？ | LLM调用封装
学习AI Agent核心原理只需读懂哪个文件？ | agents/default.py（131行代码）
CLI的全称和中文名称是什么？ | Command Line Interface（命令行接口）
CLI等同于终端吗？ | 不是，CLI是可以在终端中运行的程序
终端和CLI程序的区别是什么？ | 终端是输入命令的窗口，CLI程序是在终端里运行的命令（如ls、git、python）
python script.py命令中哪个是CLI程序？ | python是CLI程序
推荐用什么代替裸用sys.argv？ | typer或argparse
CLI=终端，这个说法对吗？ | 不对，CLI是命令行程序（在终端里运行的程序）
应该用什么解析参数？ | typer或argparse
更好的参数解析方案是什么？ | typer
python script.py中python和script.py都属于CLI吗？ | 不是，python是CLI程序，script.py是参数
script.py如何变成CLI？ | 加shebang和可执行权限
让script.py变成CLI的具体步骤是什么？ | 1.文件开头加shebang 2.添加可执行权限
CLI程序是通过什么操作的程序？ | 命令行
CLI程序的特点是什么？ | 在终端输入命令运行，通过文本参数接收输入，通过文本输出结果，没有图形界面
三种程序类型是什么？ | CLI程序、GUI程序、Web程序
判断是否是CLI程序的关键问题是什么？ | 能否在终端直接输入名字运行
CLI程序的定义是什么？ | 可以在终端里直接用名字运行的程序
CLI包装器的作用是什么？ | 给某个功能添加命令行入口
使用CLI包装器前后的运行方式区别？ | 原本只能代码调用，包装后可在终端直接运行
最简单的跨进程通信方式是什么？ | subprocess
docker run nginx中docker是什么？ | CLI包装器
什么是CLI包装器？举例说明 | docker run nginx中的docker就是CLI包装器，给docker功能添加了命令行入口
mini-swe-agent中Environment的核心职责是什么？ | 执行Agent产生的动作
Environment的两个核心方法及作用？ | execute(command)执行命令返回结果，get_template_vars()提供模板变量
三种Environment类型的作用？ | LocalEnvironment本机执行，DockerEnvironment容器执行，SingularityEnvironment HPC集群执行
mini-swe-agent中的Environment在LangChain中叫什么？ | Tool/Executor
mini-swe-agent实现中的感知、思考、行动、环境分别对应什么？ | 感知：读取Environment返回的output，思考：LLM生成bash命令，行动：Environment.execute()，环境：LocalEnvironment/DockerEnvironment
感知对应的是什么？ | 读取Environment返回的output
思考对应的是什么？ | LLM生成下一步bash命令
行动对应的是什么？ | Environment.execute()
环境对应的是什么？ | LocalEnvironment/DockerEnvironment
Agent中LLM和Environment的比喻及作用？ | LLM是大脑决定做什么，Environment是手负责执行
最简Agent框架如何设计？ | Model（LLM调用）+ Environment（执行动作）
完整Agent框架的核心循环？ | 感知→思考→规划→行动→感知（循环）
完整Agent框架除核心循环外的四个独立部分？ | Memory记忆、Model模型、Tools工具、Environment环境
mini-swe-agent的特殊设计：没有显式Tools，为什么？ | 因为它只有一个隐式工具：bash命令，所有能力都通过bash实现
Agent中Memory的职责是什么？ | 记住之前的对话和动作，存储长期知识，检索相关信息
Memory的三种记忆类型及作用？ | 短期记忆（当前消息列表）、长期记忆（向量数据库知识）、工作记忆（当前任务状态）
mini-swe-agent的Memory如何实现？ | self.messages（简单列表）
通用Agent核心循环中，构建Prompt包含什么？ | 系统提示、任务描述、历史记录、可用工具
通用Agent框架的核心循环步骤？ | 1.构建Prompt 2.调用Model 3.解析动作 4.执行动作 5.更新记忆 6.检查是否完成
MCPEnabledEnvironment的执行流程？ | 如果以"@amd:"开头：直接调用MCP Client（同进程），否则：subprocess.run执行普通bash命令
为什么需要进程间通信？ | 两个进程相互隔离，不能直接访问对方内存
subprocess使用的进程间通信方式？ | 管道（Pipe）
管道的本质是什么？ | 内核中的缓冲区
进程间通信的定义？ | 两个独立进程交换数据的方式（如管道）
绕过MCP协议直接调用需要维护什么？ | if-elif分支（每个工具一个分支）
官方MCP SDK比FastMCP更复杂体现在哪里？ | 需要手动注册handler、定义schema、路由到具体工具，而FastMCP用装饰器自动完成
FastMCP具体简化了哪些地方？ | 不需要手动写JSON Schema、不需要手动路由、不需要手动管理server生命周期
LiteLLM库的作用是什么？ | 用于调用大模型API的库
LiteLLM的核心目标是什么？ | 1.提供统一接口调用100+个LLM API 2.统一输出格式为OpenAI风格
Agent中负责推理的是哪个部分？ | LLM
Agent中负责动作执行的是哪个部分？ | Tools
Agent中负责存储过去对话的是哪个部分？ | Memory
Agent中负责循环控制的是哪个部分？ | Executor
通用agent设计中Environment是用来执行指令的吗？ | 不是，Environment是agent执行动作后的反馈/状态上下文
如何让Python脚本变成终端能执行的CLI命令？ | 1.pyproject.toml定义入口 2.pip install .安装
CLI命令入口点的作用是什么？ | 让shell知道命令对应的脚本，让shell识别命令
仅有pip install -e .能获得mcp-tool命令吗？为什么？ | 不能，文件名是mcp_tool.py，安装后只有模块，必须在pyproject.toml定义entry point
为什么使用pip install -e安装不需要配置PATH？ | pip安装的CLI会自动放到Python环境的bin目录
不定义entry point会有什么后果？ | 系统无法知道要从哪个模块执行哪个函数
将mcp-tool.py识别成mcp-tool指令的具体流程？ | 1.创建含main函数的文件 2.使用Typer并加装饰器 3.pyproject.toml定义入口 4.pip install -e安装
pyproject.toml中mcp-tool = "mcp_tool:main"的含义？ | 创建名为mcp-tool的命令，执行mcp_tool.py的main函数
pip install -e .中-e的含义和作用？ | editable mode，源代码改动会同步反映到CLI
CLI程序的定义？ | 可以在终端通过命令调用的程序
注册到系统PATH的作用和实现？ | 作用：让系统知道命令在哪，实现：Python用pip install完成
CLI程序和普通程序唯一的区别是？ | 操作系统能识别其名字并知道如何运行
三个步骤的目的？ | Shebang告诉系统用Python运行，chmod添加执行权限，mv到/usr/local/bin让系统能找到
pip install方式为什么能创建CLI？ | pip自动生成可执行文件、放到PATH、指定入口函数
CLI程序的三要素？ | 有入口（shebang）、有执行权限（chmod）、在PATH（系统能找到）
Python需要做到哪三点才能变成CLI？ | 操作系统能找到（PATH）、知道用什么运行（shebang或entry point）、有执行权限
Python文件能被终端直接运行就可以认为是？ | CLI程序
pip可以直接安装单个.py文件吗？ | 不能，pip安装的是Python包
toml中定义entry point后pip做了哪三件事？ | 1.在PATH放可执行文件 2.文件执行Python程序 3.让系统找到并识别命令
CLI的入口点写在哪个文件？ | pyproject.toml
如何让单个文件变成CLI？ | 1.文件放特定目录 2.新建pyproject.toml定义入口 3.pip install -e安装
Typer和argparse的关系？ | Typer是argparse的完全替代方案和升级版
为什么必须先有pyproject.toml才能pip install？ | 没有它pip无法识别是可安装的Python项目
pyproject.toml中mcp-tool = "mcp_tool:main"表示？ | 用户获得mcp-tool命令，执行mcp_tool.py的main函数
subprocess的作用？ | 启动外部进程，可以发送stdin、读取stdout和stderr
subprocess通过什么进行通信？ | 标准输入输出
subprocess不仅创建子进程，还负责什么？ | 父子进程之间的通信
UNIX进程模型中父子进程如何通信？ | 父→子用stdin，子→父用stdout（正常输出）或stderr（错误输出）
"FastMCP只简化server开发"这个说法对吗？ | 不对，FastMCP同时支持server和client开发
FastMCP中client能用装饰器吗？为什么？ | 不能，装饰器用于定义server端工具和功能
MCP Client的职责是什么？ | 连接MCP服务器、发出调用、读取返回数据
FastMCP中server和client的写法区别？ | Server用装饰器，Client用函数调用
如果server用官方MCP库实现，client能用FastMCP吗？ | 可以，FastMCP client可以与任何MCP server通信
FastMCP Client为什么能兼容任何MCP server？ | MCP是协议标准，只要遵循协议即可互通
pyproject.toml中mytool = "mytool:main"的含义？ | 将mytool.py的main函数映射成mytool命令
mytool = "mytool:main"的真正含义？ | 生成名为mytool的CLI命令，执行时运行mytool模块的main函数
mytool = "mytool:main"等号两侧的含义？ | 左侧mytool是CLI命令名，右侧mytool:main是Python模块与函数的入口点路径